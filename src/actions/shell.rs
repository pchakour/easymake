use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    future::Future,
    io::{BufRead, BufReader},
    pin::Pin,
    process::{Command, Stdio},
};

use crate::{
    console::{
        logger::{ActionProgressType, LogAction, Logger, ProgressStatus}
    }, emake::{self, InFile, PluginAction}
};
use config_macros::ActionDoc;

use super::Action;
pub static ID: &str = "shell";

#[derive(ActionDoc, Debug, Clone, Serialize, Deserialize)]
#[action_doc(
    id = "shell",
    short_desc = "Execute shell command.",
    description = "The cmd property allow to use `in_files` and `out_files` as variables.",
    example = "
{% raw %}
targets:
    pre_hello_world:
        steps:
            - description: Generate hello world file
              shell:
                in_files: []
                out_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                cmd: touch {{ out_files }}
    hello_world:
        deps:
            - pre_hello_world
        steps:
            - description: Echo example
              shell:
                in_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                out_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                cmd: echo 'hello world' >> {{ in_files }}
{% endraw %}
"
)]
pub struct ShellAction {
    #[action_prop(description = "Shell command to execute", required: true)]
    pub cmd: String,
    #[action_prop(description = "Specify a list of input files necessary for the command execution, can be an url.", required: false)]
    pub in_files: Option<Vec<InFile>>,
    #[action_prop(description = "Specify the list of files generated by the shell command.", required: false)]
    pub out_files: Option<Vec<String>>,
    #[action_prop(description = "Specify a command to compute a checksum of the output. Usefull when your command don't generate output files.", required: false)]
    pub checksum: Option<String>,
    #[action_prop(description = "[NOT IMPLEMENTED YET] Specify a command to clean outputs.", required: false)]
    pub clean: Option<String>,
}

pub struct Shell;


impl Action for Shell {
   fn insert_in_files<'a>(
        &'a self,
        action: &'a PluginAction,
        in_files: &'a mut Vec<InFile>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send + 'a>> {
        Box::pin(async move {
            match action {
                PluginAction::Shell { shell } => {
                    if let Some(plugin_in_files) = &shell.in_files {
                        for in_file in plugin_in_files {
                            in_files.push(in_file.clone());
                        }
                    }
                }
                _ => {}
            }
        })
    }

    fn insert_out_files<'a>(
        &'a self,
        action: &'a PluginAction,
        out_files: &'a mut Vec<String>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send + 'a>> {
        Box::pin(async move {
            match action {
                PluginAction::Shell { shell } => {
                    if let Some(plugin_out_files) = &shell.out_files {
                        for out_file in plugin_out_files {
                            out_files.push(out_file.clone());
                        }
                    }
                }
                _ => {}
            }
        })
    }

    fn run<'a>(
        &'a self,
        cwd: &'a str,
        target_id: &'a str,
        step_id: &'a str,
        emakefile_cwd: &'a str,
        _silent: bool,
        action: &'a PluginAction,
        in_files: &'a Vec<String>,
        out_files: &'a Vec<String>,
        _working_dir: &'a String,
        maybe_replacements: Option<&'a HashMap<String, String>>,
    ) -> Pin<Box<dyn Future<Output = bool> + Send + 'a>> {
        Box::pin(async move {
            if let PluginAction::Shell { shell } = action {
                let mut command = shell.cmd.clone();
                let in_files_string = in_files.join(" ");
                let out_files_string = out_files.join(" ");

                let mut replacements = HashMap::from([
                    ("in_files".into(), in_files_string),
                    ("out_files".into(), out_files_string),
                ]);

                for (i, f) in in_files.iter().enumerate() {
                    replacements.insert(format!("in_files[{}]", i), f.clone());
                }
                for (i, f) in out_files.iter().enumerate() {
                    replacements.insert(format!("out_files[{}]", i), f.clone());
                }

                if let Some(defaults) = maybe_replacements {
                    replacements.extend(defaults.clone());
                }

                command = emake::compiler::compile(
                    cwd,
                    &command,
                    &emakefile_cwd.to_string(),
                    Some(&replacements),
                );

                let action_id = format!(
                    "{}{}{}{}{}",
                    target_id,
                    step_id,
                    ID,
                    in_files.join(";"),
                    out_files.join(";")
                );

                Logger::set_action(
                    target_id.to_string(),
                    step_id.to_string(),
                    LogAction {
                        id: action_id.clone(),
                        status: ProgressStatus::Progress,
                        description: format!("Running command: {}", command),
                        progress: ActionProgressType::Spinner,
                        percent: None,
                    },
                );

                let (shell, arg) = if cfg!(windows) {
                    ("cmd", "/C")
                } else {
                    ("sh", "-c")
                };

                let mut child = Command::new(shell)
                    .current_dir(cwd)
                    .arg(arg)
                    .arg(&command)
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .spawn()
                    .expect("Failed to execute command");

                let stdout = child.stdout.take().unwrap();
                let stderr = child.stderr.take().unwrap();

                let stdout_reader = BufReader::new(stdout);
                let stderr_reader = BufReader::new(stderr);

                let tid_stdout = target_id.to_string();
                let sid_stdout = step_id.to_string();
                let aid_stdout = action_id.clone();
                let cmd_stdout = command.clone();

                let stdout_thread = std::thread::spawn(move || {
                    let mut outputs = Vec::new();
                    for line in stdout_reader.lines() {
                        if let Ok(text) = line {
                            let output = format!("{}\n[stdout] {}", cmd_stdout, text);
                            Logger::set_action(
                                tid_stdout.clone(),
                                sid_stdout.clone(),
                                LogAction {
                                    id: aid_stdout.clone(),
                                    status: ProgressStatus::Progress,
                                    description: output.clone(),
                                    progress: ActionProgressType::Spinner,
                                    percent: None,
                                },
                            );
                            outputs.push(output.clone());
                        }
                    }
                    outputs
                });

                let tid_stderr = target_id.to_string();
                let sid_stderr = step_id.to_string();
                let aid_stderr = action_id.clone();
                let cmd_stderr = command.clone();

                let stderr_thread = std::thread::spawn(move || {
                    let mut errors = Vec::new();
                    for line in stderr_reader.lines() {
                        if let Ok(text) = line {
                            errors.push(text.clone());
                            Logger::set_action(
                                tid_stderr.clone(),
                                sid_stderr.clone(),
                                LogAction {
                                    id: aid_stderr.clone(),
                                    status: ProgressStatus::Progress,
                                    description: format!("{}\n[stderr] {}", cmd_stderr, text),
                                    progress: ActionProgressType::Spinner,
                                    percent: None,
                                },
                            );
                        }
                    }
                    errors
                });

                let status = child.wait().expect("Failed to wait on child");
                let output = stdout_thread.join().unwrap();
                let errors = stderr_thread.join().unwrap();

                if !status.success() {
                    Logger::set_action(
                        target_id.to_string(),
                        step_id.to_string(),
                        LogAction {
                            id: action_id.clone(),
                            status: ProgressStatus::Failed,
                            description: format!(
                                "Command `{}` failed with exit code {}.\n{}",
                                command,
                                status.code().unwrap_or(-1),
                                errors.join("\n")
                            ),
                            progress: ActionProgressType::Spinner,
                            percent: None,
                        },
                    );
                    return true;
                }

                Logger::set_action(
                    target_id.to_string(),
                    step_id.to_string(),
                    LogAction {
                        id: action_id,
                        status: ProgressStatus::Done,
                        description: format!("Command `{}` completed successfully\n{}", command, output.join("\n")),
                        progress: ActionProgressType::None,
                        percent: None,
                    },
                );

                false
            } else {
                false
            }
        })
    }

    fn clone_box(&self) -> Box<dyn Action + Send + Sync> {
        Box::new(Self)
    }
}
