use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    future::Future,
    io::{BufRead, BufReader},
    pin::Pin,
    process::{Command, Stdio},
};

use crate::{
    console::log,
    emake::{self, InFile, PluginAction},
};
use config_macros::ActionDoc;

use super::Action;
pub static ID: &str = "shell";

#[derive(ActionDoc, Debug, Clone, Serialize, Deserialize)]
#[action_doc(
    id = "shell",
    short_desc = "Execute shell command.",
    description = "The cmd property allow to use `in_files` and `out_files` as variables.",
    example = "
{% raw %}
targets:
    pre_hello_world:
        steps:
            - description: Generate hello world file
              shell:
                in_files: []
                out_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                cmd: touch {{ out_files }}
    hello_world:
        deps:
            - pre_hello_world
        steps:
            - description: Echo example
              shell:
                in_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                out_files: [\"{{ EMAKE_WORKING_DIR }}/hello_world.txt\"]
                cmd: echo 'hello world' >> {{ in_files }}
{% endraw %}
"
)]
#[serde(deny_unknown_fields)]
pub struct ShellAction {
    #[action_prop(description = "Shell command to execute", required: true)]
    pub cmd: String,
    #[action_prop(description = "Specify a list of input files necessary for the command execution, can be an url.", required: false)]
    pub in_files: Option<Vec<InFile>>,
    #[action_prop(description = "Specify the list of files generated by the shell command.", required: false)]
    pub out_files: Option<Vec<String>>,
    #[action_prop(description = "Specify a command to compute a checksum of the output. Usefull when your command don't generate output files.", required: false)]
    pub checksum: Option<String>,
    #[action_prop(description = "[NOT IMPLEMENTED YET] Specify a command to clean outputs.", required: false)]
    pub clean: Option<String>,
}

pub struct Shell;

impl Action for Shell {
    fn insert_in_files<'a>(
        &'a self,
        action: &'a PluginAction,
        in_files: &'a mut Vec<InFile>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send + 'a>> {
        Box::pin(async move {
            match action {
                PluginAction::Shell { shell } => {
                    if let Some(plugin_in_files) = &shell.in_files {
                        for in_file in plugin_in_files {
                            in_files.push(in_file.clone());
                        }
                    }
                }
                _ => {}
            }
        })
    }

    fn insert_out_files<'a>(
        &'a self,
        action: &'a PluginAction,
        out_files: &'a mut Vec<String>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send + 'a>> {
        Box::pin(async move {
            match action {
                PluginAction::Shell { shell } => {
                    if let Some(plugin_out_files) = &shell.out_files {
                        for out_file in plugin_out_files {
                            out_files.push(out_file.clone());
                        }
                    }
                }
                _ => {}
            }
        })
    }

    fn run<'a>(
        &'a self,
        cwd: &'a str,
        _target_id: &'a str,
        step_id: &'a str,
        emakefile_cwd: &'a str,
        _silent: bool,
        action: &'a PluginAction,
        in_files: &'a Vec<String>,
        out_files: &'a Vec<String>,
        _working_dir: &'a String,
        maybe_replacements: Option<&'a HashMap<String, String>>,
    ) -> Pin<Box<dyn Future<Output = Result<(), Box<dyn std::error::Error>>> + Send + 'a>> {
        Box::pin(async move {
            if let PluginAction::Shell { shell } = action {
                let mut command = shell.cmd.clone();
                let in_files_string = in_files.join(" ");
                let out_files_string = out_files.join(" ");

                log::debug!("In files vec {:?}", in_files);
                log::debug!("In files string {:?}", in_files_string);
                let mut replacements = HashMap::from([
                    ("in_files".into(), in_files_string),
                    ("out_files".into(), out_files_string),
                ]);

                for (i, f) in in_files.iter().enumerate() {
                    replacements.insert(format!("in_files[{}]", i), f.clone());
                }
                for (i, f) in out_files.iter().enumerate() {
                    replacements.insert(format!("out_files[{}]", i), f.clone());
                }

                if let Some(defaults) = maybe_replacements {
                    replacements.extend(defaults.clone());
                }

                command = emake::compiler::compile(
                    cwd,
                    &command,
                    &emakefile_cwd.to_string(),
                    Some(&replacements),
                );

                let (shell, arg) = if cfg!(windows) {
                    ("cmd", "/C")
                } else {
                    ("sh", "-c")
                };

                let mut child = Command::new(shell)
                    .current_dir(cwd)
                    .arg(arg)
                    .arg(&command)
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .spawn()
                    .expect("Failed to execute command");

                let stdout = child.stdout.take().unwrap();
                let stderr = child.stderr.take().unwrap();

                let stdout_reader = BufReader::new(stdout);
                let stderr_reader = BufReader::new(stderr);
                let cmd_stdout = command.clone();

                log::action_info!(step_id, self::ID, "[command] {}", cmd_stdout);
                let stdout_step_id_clone = String::from(step_id);

                let _ = std::thread::spawn(move || {
                    for line in stdout_reader.lines() {
                        if let Ok(text) = line {
                            let output = format!("[stdout] {}", text);
                            log::action_info!(stdout_step_id_clone, ID, "{}", output);
                        }
                    }
                });

                let stderr_step_id_clone = String::from(step_id);
                let _ = std::thread::spawn(move || {
                    for line in stderr_reader.lines() {
                        if let Ok(text) = line {
                            let output = format!("[stderr] {}", text);
                            log::action_info!(stderr_step_id_clone, ID, "{}", output);
                        }
                    }
                });

                let status = child.wait().expect("Failed to wait on child");

                if !status.success() {
                    return Err(format!(
                        "Command `{}` failed with exit code {}.",
                        command,
                        status.code().unwrap_or(-1)
                    )
                    .into());
                }
            }

            Ok(())
        })
    }

    fn clone_box(&self) -> Box<dyn Action + Send + Sync> {
        Box::new(Self)
    }
    fn get_checksum(&self) -> Option<String> {
        None
    }
}
